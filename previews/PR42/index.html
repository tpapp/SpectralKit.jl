<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SpectralKit · SpectralKit.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>SpectralKit.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>SpectralKit</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li><li><a class="tocitem" href="#Constructing-bases"><span>Constructing bases</span></a></li><li><a class="tocitem" href="#Using-bases"><span>Using bases</span></a></li><li><a class="tocitem" href="#Derivatives"><span>Derivatives</span></a></li><li><a class="tocitem" href="#Internals"><span>Internals</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>SpectralKit</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>SpectralKit</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tpapp/SpectralKit.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SpectralKit"><a class="docs-heading-anchor" href="#SpectralKit">SpectralKit</a><a id="SpectralKit-1"></a><a class="docs-heading-anchor-permalink" href="#SpectralKit" title="Permalink"></a></h1><p>This is a very simple package for <em>building blocks</em> of spectral methods. Its intended audience is users who are familiar with the theory and practice of these methods, and prefer to assemble their code from modular building blocks. If you need an introduction, a book like <em>Boyd (2001): Chebyshev and Fourier spectral methods</em> is a good place to start.</p><p>The package is optimized for solving functional equations, as usually encountered in economics when solving discrete and continuous-time problems. It uses <a href="https://github.com/JuliaArrays/StaticArrays.jl">static arrays</a> extensively to avoid allocation and unroll <em>some</em> loops. Key functionality includes evaluating a set of basis functions, their linear combination at arbitrary points in a fast manner, for use in threaded code. These should work seamlessly with automatic differentiation frameworks, but also has its own primitives for obtaining derivatives of basis functions.</p><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>In this package,</p><ol><li><p>A <em>basis</em> is a finite family of functions for approximating other functions. The <a href="#SpectralKit.dimension"><code>dimension</code></a> of a basis tells you how many functions are in there, while <a href="#SpectralKit.domain"><code>domain</code></a> can be used to query its domain.</p></li><li><p>A <a href="#SpectralKit.grid"><code>grid</code></a> is vector of <em>suggested</em> gridpoints for evaluating the function to be approximated that has useful theoretical properties. You can contruct a <a href="#SpectralKit.collocation_matrix"><code>collocation_matrix</code></a> using this grid (or any other set of points). Grids are associated with bases at the time of their construction: a basis with the same set of functions can have different grids.</p></li><li><p><a href="#SpectralKit.basis_at"><code>basis_at</code></a> returns an <em>iterator</em> for evaluating basis functions at an arbitrary point inside their domain. This iterator is meant to be heavily optimized and non-allocating. <a href="#SpectralKit.linear_combination"><code>linear_combination</code></a> is a convenience wrapper for obtaining a linear combination of basis functions at a given point.</p></li></ol><p>A basis is constructed using</p><ol><li><p>a family on a <em>fixed</em> domain, eg <a href="#SpectralKit.Chebyshev"><code>Chebyshev</code></a>,</p></li><li><p>a grid specification like <a href="#SpectralKit.InteriorGrid"><code>InteriorGrid</code></a>,</p></li><li><p>a number of parameters that determine the number of basis functions.</p></li></ol><p>A set of coordinates for a particular basis can be augmented for a wider basis with <a href="#SpectralKit.augment_coefficients"><code>augment_coefficients</code></a>.</p><p>Currenly, all bases have the domain <span>$[-1,1]$</span> or <span>$[-1,1]^n$</span>. Facilities are provided for coordinatewise <em>transformations</em> to other domains.</p><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><h3 id="Univariate-family-on-[-1,1]"><a class="docs-heading-anchor" href="#Univariate-family-on-[-1,1]">Univariate family on <code>[-1,1]</code></a><a id="Univariate-family-on-[-1,1]-1"></a><a class="docs-heading-anchor-permalink" href="#Univariate-family-on-[-1,1]" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SpectralKit</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; basis = Chebyshev(EndpointGrid(), 5)        # 5 Chebyshev polynomials</code><code class="nohighlight hljs ansi" style="display:block;">Chebyshev polynomials (1st kind), EndpointGrid(), dimension: 5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; is_function_basis(basis)                    # ie we support the interface below</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dimension(basis)                            # number of basis functions</code><code class="nohighlight hljs ansi" style="display:block;">5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; domain(basis)                               # domain</code><code class="nohighlight hljs ansi" style="display:block;">(-1, 1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; grid(basis)                                 # Gauss-Lobatto grid</code><code class="nohighlight hljs ansi" style="display:block;">SpectralKit.ChebyshevGridIterator{Float64, Chebyshev{EndpointGrid}}(Chebyshev polynomials (1st kind), EndpointGrid(), dimension: 5)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(basis_at(basis, 0.41))              # iterator for basis functions at 0.41</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Float64}:
  1.0
  0.41
 -0.6638000000000001
 -0.9543159999999999
 -0.11873911999999986</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(basis_at(basis, derivatives(0.41))) # values and 1st derivatives</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{SpectralKit.Derivatives{0, 2, Float64}}:
 SpectralKit.Derivatives{0, 2, Float64}((1.0, 0.0))
 SpectralKit.Derivatives{0, 2, Float64}((0.41, 1.0))
 SpectralKit.Derivatives{0, 2, Float64}((-0.6638000000000001, 1.64))
 SpectralKit.Derivatives{0, 2, Float64}((-0.9543159999999999, -0.9828000000000003))
 SpectralKit.Derivatives{0, 2, Float64}((-0.11873911999999986, -4.354528))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; θ = [1, 0.5, 0.2, 0.3, 0.001]               # a vector of coefficients</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Float64}:
 1.0
 0.5
 0.2
 0.3
 0.001</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; linear_combination(basis, θ, 0.41)          # combination at some value</code><code class="nohighlight hljs ansi" style="display:block;">0.7858264608800001</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; linear_combination(basis, θ)(0.41)          # also as a callable</code><code class="nohighlight hljs ansi" style="display:block;">0.7858264608800001</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; basis2 = Chebyshev(EndpointGrid(), 8)       # 8 Chebyshev polynomials</code><code class="nohighlight hljs ansi" style="display:block;">Chebyshev polynomials (1st kind), EndpointGrid(), dimension: 8</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; is_subset_basis(basis, basis2)              # we could augment θ …</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; augment_coefficients(basis, basis2, θ)      # … so let&#39;s do it</code><code class="nohighlight hljs ansi" style="display:block;">8-element Vector{Float64}:
 1.0
 0.5
 0.2
 0.3
 0.001
 0.0
 0.0
 0.0</code></pre><h3 id="Smolyak-approximation-on-a-transformed-domain"><a class="docs-heading-anchor" href="#Smolyak-approximation-on-a-transformed-domain">Smolyak approximation on a transformed domain</a><a id="Smolyak-approximation-on-a-transformed-domain-1"></a><a class="docs-heading-anchor-permalink" href="#Smolyak-approximation-on-a-transformed-domain" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SpectralKit, StaticArrays</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f2(x)                  # bivariate function we approximate
           x1, x2 = x                  # takes vectors
           exp(x1) + exp(-abs2(x2))
       end</code><code class="nohighlight hljs ansi" style="display:block;">f2 (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ct = coordinate_transformations(BoundedLinear(-1, 2.0), SemiInfRational(-3.0, 3.0))</code><code class="nohighlight hljs ansi" style="display:block;">coordinate transformations
  (-1.0,2.0) ↔ (-1, 1) [linear transformation]
  (-3.0,∞) ↔ (-1, 1) [rational transformation with scale 3.0]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; basis = smolyak_basis(Chebyshev, InteriorGrid2(), SmolyakParameters(3), 2)</code><code class="nohighlight hljs ansi" style="display:block;">Sparse multivariate basis on ℝ²
  Smolyak indexing, ∑bᵢ ≤ 3, all bᵢ ≤ 3, dimension 49
  using Chebyshev polynomials (1st kind), InteriorGrid2(), dimension: 15</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = grid(basis)</code><code class="nohighlight hljs ansi" style="display:block;">SpectralKit.SmolyakGridIterator{Tuple{Float64, Float64}, SpectralKit.SmolyakIndices{2, 15, 3, 3, 4}, StaticArraysCore.SVector{15, Float64}}(Smolyak indexing, ∑bᵢ ≤ 3, all bᵢ ≤ 3, dimension 49, [0.0, -0.7071067811865476, 0.7071067811865476, -0.9238795325112867, -0.3826834323650898, 0.3826834323650898, 0.9238795325112867, -0.9807852804032304, -0.8314696123025452, -0.5555702330196022, -0.19509032201612828, 0.19509032201612828, 0.5555702330196022, 0.8314696123025452, 0.9807852804032304])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; θ = collocation_matrix(basis) \ f2.(from_pm1.(ct, x)) # find the coefficients</code><code class="nohighlight hljs ansi" style="display:block;">49-element Vector{Float64}:
  2.77932202173247
  3.2369886430572152
  1.11399024245779
  0.26634799650310004
  0.048598256445250225
  0.007157295461751146
  0.0008829533666789691
  9.36685282975687e-5
  8.713768913978298e-6
  7.216598514600189e-7
  ⋮
 -1.0068617911699917e-16
  0.030107750183198983
  0.04841175934096233
 -0.032224729551577076
 -0.16530952363028054
  0.016396633184324366
  0.0122595627243983
 -0.01591087240587925
 -0.1408521904743876</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; z = (0.5, 0.7)                                        # evaluate at this point</code><code class="nohighlight hljs ansi" style="display:block;">(0.5, 0.7)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isapprox(f2(z), linear_combination(basis, θ, to_pm1(ct, z)), rtol = 0.005)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h2 id="Constructing-bases"><a class="docs-heading-anchor" href="#Constructing-bases">Constructing bases</a><a id="Constructing-bases-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-bases" title="Permalink"></a></h2><h3 id="Grid-specifications"><a class="docs-heading-anchor" href="#Grid-specifications">Grid specifications</a><a id="Grid-specifications-1"></a><a class="docs-heading-anchor-permalink" href="#Grid-specifications" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SpectralKit.EndpointGrid" href="#SpectralKit.EndpointGrid"><code>SpectralKit.EndpointGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct EndpointGrid &lt;: SpectralKit.AbstractGrid</code></pre><p>Grid that includes endpoints (eg Gauss-Lobatto).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For small dimensions may fall back to a grid that does not contain endpoints.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/SpectralKit.jl/blob/c0d35f7a61f57a7e6885173c7e1583c3757b4ba0/src/generic_api.jl#L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralKit.InteriorGrid" href="#SpectralKit.InteriorGrid"><code>SpectralKit.InteriorGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct InteriorGrid &lt;: SpectralKit.AbstractGrid</code></pre><p>Grid with interior points (eg Gauss-Chebyshev).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/SpectralKit.jl/blob/c0d35f7a61f57a7e6885173c7e1583c3757b4ba0/src/generic_api.jl#L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralKit.InteriorGrid2" href="#SpectralKit.InteriorGrid2"><code>SpectralKit.InteriorGrid2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct InteriorGrid2 &lt;: SpectralKit.AbstractGrid</code></pre><p>Grid with interior points that results in smaller grids than <code>InteriorGrid</code> when nested. Equivalent to an <code>EndpointGrid</code> with endpoints dropped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/SpectralKit.jl/blob/c0d35f7a61f57a7e6885173c7e1583c3757b4ba0/src/generic_api.jl#L136">source</a></section></article><h3 id="Univariate-and-multivariate-transformations"><a class="docs-heading-anchor" href="#Univariate-and-multivariate-transformations">Univariate and multivariate transformations</a><a id="Univariate-and-multivariate-transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Univariate-and-multivariate-transformations" title="Permalink"></a></h3><p>Bases are defined on the domain <span>$[-1, 1]$</span> or <span>$[-1, 1]^n$</span>. <em>Transformations</em> map other uni- and multivariate sets into these domains.</p><article class="docstring"><header><a class="docstring-binding" id="SpectralKit.to_pm1" href="#SpectralKit.to_pm1"><code>SpectralKit.to_pm1</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>to_pm1(transformation, x)</code></p><p>Transform <code>x</code> to <span>$[-1, 1]$</span> using <code>transformation</code>.</p><p>Supports partial application as <code>to_pm1(transformation)</code>.</p><p>!!! FIXME     document, especially differentiability requirements at infinite endpoints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/SpectralKit.jl/blob/c0d35f7a61f57a7e6885173c7e1583c3757b4ba0/src/transformations.jl#L35-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralKit.from_pm1" href="#SpectralKit.from_pm1"><code>SpectralKit.from_pm1</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>from_pm1(transformation, x)</code></p><p>Transform <code>x</code> from <span>$[-1, 1]$</span> using <code>transformation</code>.</p><p>Supports partial application as <code>from_pm1(transformation)</code>.</p><p>!!! FIXME     document, especially differentiability requirements at infinite endpoints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/SpectralKit.jl/blob/c0d35f7a61f57a7e6885173c7e1583c3757b4ba0/src/transformations.jl#L49-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralKit.BoundedLinear" href="#SpectralKit.BoundedLinear"><code>SpectralKit.BoundedLinear</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BoundedLinear{T&lt;:Real} &lt;: SpectralKit.UnivariateTransformation</code></pre><p>Transform <code>x ∈ (-1,1)</code> to <code>y ∈ (a, b)</code>, using <span>$y = x ⋅ s + m$</span>.</p><p><code>m</code> and <code>s</code> are calculated and checked by the constructor; <code>a &lt; b</code> is enforced.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/SpectralKit.jl/blob/c0d35f7a61f57a7e6885173c7e1583c3757b4ba0/src/transformations.jl#L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralKit.InfRational" href="#SpectralKit.InfRational"><code>SpectralKit.InfRational</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InfRational(A, L)
</code></pre><p>Chebyshev polynomials transformed to the domain <code>(-Inf, Inf)</code> using <span>$y = A + L ⋅ x / √(1 - x^2)$</span>, with <code>L &gt; 0</code>.</p><p><strong>Example mappings</strong></p><ul><li><span>$0 ↦ A$</span></li><li><span>$±0.5 ↦ A ± L / √3$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/SpectralKit.jl/blob/c0d35f7a61f57a7e6885173c7e1583c3757b4ba0/src/transformations.jl#L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralKit.SemiInfRational" href="#SpectralKit.SemiInfRational"><code>SpectralKit.SemiInfRational</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SemiInfRational(A, L)
</code></pre><p><code>[-1,1]</code> transformed to the domain <code>[A, Inf)</code> (when <code>L &gt; 0</code>) or <code>(-Inf,A]</code> (when <code>L &lt; 0</code>) using <span>$y = A + L ⋅ (1 + x) / (1 - x)$</span>.</p><p>When used with Chebyshev polynomials, also known as a “rational Chebyshev” basis.</p><p><strong>Example mappings</strong></p><ul><li><span>$-1/2 ↦ A + L / 3$</span></li><li><span>$0 ↦ A + L$</span></li><li><span>$1/2 ↦ A + 3 ⋅ L$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/SpectralKit.jl/blob/c0d35f7a61f57a7e6885173c7e1583c3757b4ba0/src/transformations.jl#L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralKit.coordinate_transformations" href="#SpectralKit.coordinate_transformations"><code>SpectralKit.coordinate_transformations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coordinate_transformations(transformations)
</code></pre><p>Wrapper for coordinate-wise transformations.</p><pre><code class="language-julia-repl hljs">julia&gt; using StaticArrays

julia&gt; ct = coordinate_transformations(BoundedLinear(0, 2), SemiInfRational(2, 3))
coordinate transformations
  (0.0,2.0) ↔ (-1, 1) [linear transformation]
  (2,∞) ↔ (-1, 1) [rational transformation with scale 3]

julia&gt; x = from_pm1(ct, (0.4, 0.5))
(1.4, 11.0)

julia&gt; y = to_pm1(ct, x)
(0.3999999999999999, 0.5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/SpectralKit.jl/blob/c0d35f7a61f57a7e6885173c7e1583c3757b4ba0/src/transformations.jl#L81">source</a></section></article><h3 id="Univariate-bases"><a class="docs-heading-anchor" href="#Univariate-bases">Univariate bases</a><a id="Univariate-bases-1"></a><a class="docs-heading-anchor-permalink" href="#Univariate-bases" title="Permalink"></a></h3><p>Currently, only Chebyshev polynomials are implemented. Univariate bases operate on real numbers.</p><article class="docstring"><header><a class="docstring-binding" id="SpectralKit.Chebyshev" href="#SpectralKit.Chebyshev"><code>SpectralKit.Chebyshev</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Chebyshev{K&lt;:SpectralKit.AbstractGrid} &lt;: SpectralKit.FunctionBasis</code></pre><p>The first <code>N</code> Chebyhev polynomials of the first kind, defined on <code>[-1,1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/SpectralKit.jl/blob/c0d35f7a61f57a7e6885173c7e1583c3757b4ba0/src/chebyshev.jl#L7">source</a></section></article><h3 id="Multivariate-bases"><a class="docs-heading-anchor" href="#Multivariate-bases">Multivariate bases</a><a id="Multivariate-bases-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-bases" title="Permalink"></a></h3><p>Multivariate bases operate on tuples or vectors (<code>StaticArrays.SVector</code> is preferred for performance, but all <code>&lt;:AbstractVector</code> types should work).</p><article class="docstring"><header><a class="docstring-binding" id="SpectralKit.SmolyakParameters" href="#SpectralKit.SmolyakParameters"><code>SpectralKit.SmolyakParameters</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SmolyakParameters(B)
SmolyakParameters(B, M)
</code></pre><p>Parameters for Smolyak grids that are independent of the dimension of the domain.</p><p>Polynomials are organized into blocks of <code>1, 2, 2, 4, 8, 16, …</code> polynomials (and corresponding gridpoints), indexed with a <em>block index</em> <code>b</code> that starts at <code>0</code>. <code>B ≥ ∑ bᵢ</code> and <code>0 ≤ bᵢ ≤ M</code> constrain the number of blocks along each dimension <code>i</code>.</p><p><code>M &gt; B</code> is not an error, but will be normalized to <code>M = B</code> with a warning.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/SpectralKit.jl/blob/c0d35f7a61f57a7e6885173c7e1583c3757b4ba0/src/smolyak_api.jl#L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralKit.smolyak_basis" href="#SpectralKit.smolyak_basis"><code>SpectralKit.smolyak_basis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">smolyak_basis(
    univariate_family,
    grid_kind,
    smolyak_parameters,
    _
)
</code></pre><p>Create a sparse Smolyak basis.</p><p><strong>Arguments</strong></p><ul><li><p><code>univariate_family</code>: should be a callable that takes a <code>grid_kind</code> and a <code>dimension</code> parameter, eg <code>Chebyshev</code>.</p></li><li><p><code>grid_kind</code>: the grid kind, eg <code>InteriorGrid()</code> etc.</p></li><li><p><code>smolyak_parameters</code>: the Smolyak grid specification parameters, see <a href="#SpectralKit.SmolyakParameters"><code>SmolyakParameters</code></a>.</p></li><li><p><code>N</code>: the dimension. wrapped in a <code>Val</code> for type stability, a convenience constructor also takes integers.</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; basis = smolyak_basis(Chebyshev, InteriorGrid(), SmolyakParameters(3), 2)
Sparse multivariate basis on ℝ²
  Smolyak indexing, ∑bᵢ ≤ 3, all bᵢ ≤ 3, dimension 81
  using Chebyshev polynomials (1st kind), InteriorGrid(), dimension: 27

julia&gt; dimension(basis)
81

julia&gt; domain(basis)
((-1, 1), (-1, 1))</code></pre><p><strong>Properties</strong></p><p><em>Grids nest</em>: increasing arguments of <code>SmolyakParameters</code> result in a refined grid that contains points of the cruder grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/SpectralKit.jl/blob/c0d35f7a61f57a7e6885173c7e1583c3757b4ba0/src/smolyak_api.jl#L170">source</a></section></article><h2 id="Using-bases"><a class="docs-heading-anchor" href="#Using-bases">Using bases</a><a id="Using-bases-1"></a><a class="docs-heading-anchor-permalink" href="#Using-bases" title="Permalink"></a></h2><h3 id="Introspection"><a class="docs-heading-anchor" href="#Introspection">Introspection</a><a id="Introspection-1"></a><a class="docs-heading-anchor-permalink" href="#Introspection" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SpectralKit.is_function_basis" href="#SpectralKit.is_function_basis"><code>SpectralKit.is_function_basis</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>is_function_basis(F)</code></p><p><code>is_function_basis(f::F)</code></p><p>Test if the argument is a <em>function basis</em>, supporting the following interface:</p><ul><li><p><a href="#SpectralKit.domain"><code>domain</code></a> for querying the domain,</p></li><li><p><a href="#SpectralKit.dimension"><code>dimension</code></a> for the dimension,</p></li><li><p><a href="#SpectralKit.basis_at"><code>basis_at</code></a> for function evaluation,</p></li><li><p><a href="#SpectralKit.grid"><code>grid</code></a> to obtain collocation points.</p></li></ul><p><a href="#SpectralKit.linear_combination"><code>linear_combination</code></a> and <a href="#SpectralKit.collocation_matrix"><code>collocation_matrix</code></a> are also supported, building on the above.</p><p>Can be used on both types (preferred) and values (for convenience).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/SpectralKit.jl/blob/c0d35f7a61f57a7e6885173c7e1583c3757b4ba0/src/generic_api.jl#L20-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralKit.dimension" href="#SpectralKit.dimension"><code>SpectralKit.dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>dimension(basis)</code></p><p>Return the dimension of <code>basis</code>, a positive <code>Int</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/SpectralKit.jl/blob/c0d35f7a61f57a7e6885173c7e1583c3757b4ba0/src/generic_api.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralKit.domain" href="#SpectralKit.domain"><code>SpectralKit.domain</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>domain(basis)</code></p><p>The domain of a function basis. A tuple of numbers (of arbitrary type, but usually <code>Float64</code>), or a tuple of domains by coordinate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/SpectralKit.jl/blob/c0d35f7a61f57a7e6885173c7e1583c3757b4ba0/src/generic_api.jl#L46-L51">source</a></section></article><h3 id="Evaluation"><a class="docs-heading-anchor" href="#Evaluation">Evaluation</a><a id="Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SpectralKit.basis_at" href="#SpectralKit.basis_at"><code>SpectralKit.basis_at</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>basis_at(basis, x)</code></p><p>Return an iterable with known element type and length (<code>Base.HasEltype()</code>, <code>Base.HasLength()</code>) of basis functions in <code>basis</code> evaluated at <code>x</code>.</p><p>Univariate bases operate on real numbers, while for multivariate bases, <code>Tuple</code>s or <code>StaticArrays.SVector</code> are preferred for performance, though all <code>&lt;:AbstractVector</code> types should work.</p><p>Methods are type stable.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Consequences are undefined when evaluating outside the domain.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/SpectralKit.jl/blob/c0d35f7a61f57a7e6885173c7e1583c3757b4ba0/src/generic_api.jl#L61-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralKit.linear_combination" href="#SpectralKit.linear_combination"><code>SpectralKit.linear_combination</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">linear_combination(basis, θ, x)
</code></pre><p>Evaluate the linear combination of <span>$∑ θₖ⋅fₖ(x)$</span> of function basis <span>$f₁, …$</span> at <code>x</code>, for the given order.</p><p>The length of <code>θ</code> should equal <code>dimension(θ)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/SpectralKit.jl/blob/c0d35f7a61f57a7e6885173c7e1583c3757b4ba0/src/generic_api.jl#L83">source</a></section><section><div><pre><code class="language-julia hljs">linear_combination(basis, θ)
</code></pre><p>Return a callable that calculates <code>linear_combination(basis, θ, x)</code> when called with <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/SpectralKit.jl/blob/c0d35f7a61f57a7e6885173c7e1583c3757b4ba0/src/generic_api.jl#L105">source</a></section></article><h3 id="Grids-and-collocation"><a class="docs-heading-anchor" href="#Grids-and-collocation">Grids and collocation</a><a id="Grids-and-collocation-1"></a><a class="docs-heading-anchor-permalink" href="#Grids-and-collocation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SpectralKit.grid" href="#SpectralKit.grid"><code>SpectralKit.grid</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>grid([T], basis)</code></p><p>Return an iterator for the grid recommended for collocation, with <code>dimension(basis)</code> elements.</p><p><code>T</code> for the element type of grid coordinates, and defaults to <code>Float64</code>. Methods are type stable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/SpectralKit.jl/blob/c0d35f7a61f57a7e6885173c7e1583c3757b4ba0/src/generic_api.jl#L146-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralKit.collocation_matrix" href="#SpectralKit.collocation_matrix"><code>SpectralKit.collocation_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">collocation_matrix(basis)
collocation_matrix(basis, x)
</code></pre><p>Convenience function to obtain a “collocation matrix” at points <code>x</code>, which is assumed to have a concrete <code>eltype</code>. The default is <code>x = grid(basis)</code>, specialized methods may exist for this when it makes sense.</p><p>The collocation matrix may not be an <code>AbstractMatrix</code>, all it needs to support is <code>C \ y</code> for compatible vectors <code>y = f.(x)</code>.</p><p>Methods are type stable. The elements of <code>x</code> can be <a href="#SpectralKit.derivatives"><code>derivatives</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/SpectralKit.jl/blob/c0d35f7a61f57a7e6885173c7e1583c3757b4ba0/src/generic_api.jl#L157">source</a></section></article><h3 id="Augment-coordinates-for-a-wider-basis"><a class="docs-heading-anchor" href="#Augment-coordinates-for-a-wider-basis">Augment coordinates for a wider basis</a><a id="Augment-coordinates-for-a-wider-basis-1"></a><a class="docs-heading-anchor-permalink" href="#Augment-coordinates-for-a-wider-basis" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SpectralKit.augment_coefficients" href="#SpectralKit.augment_coefficients"><code>SpectralKit.augment_coefficients</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>augment_coefficients(basis1, basis2, θ1)</code></p><p>Return a set of coefficients <code>θ2</code> for <code>basis2</code> such that</p><pre><code class="language-julia hljs">linear_combination(basis1, θ1, x) == linear_combination(basis2, θ2, x)</code></pre><p>for any <code>x</code> in the domain. In practice this means padding with zeros.</p><p>Throw a <code>ArgumentError</code> if the bases are incompatible with each other or <code>x</code>, or this is not possible. Methods may not be defined for incompatible bases, compatibility between bases can be checked with <a href="#SpectralKit.is_subset_basis"><code>is_subset_basis</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/SpectralKit.jl/blob/c0d35f7a61f57a7e6885173c7e1583c3757b4ba0/src/generic_api.jl#L182-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralKit.is_subset_basis" href="#SpectralKit.is_subset_basis"><code>SpectralKit.is_subset_basis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_subset_basis(basis1, basis2)
</code></pre><p>Return a <code>Bool</code> indicating whether coefficients in <code>basis1</code> can be augmented to <code>basis2</code> with <a href="#SpectralKit.augment_coefficients"><code>augment_coefficients</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>true</code> does not mean that coefficients from <code>basis1</code> can just be padded with zeros, since they may be in different positions. Always use <a href="#SpectralKit.augment_coefficients"><code>augment_coefficients</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/SpectralKit.jl/blob/c0d35f7a61f57a7e6885173c7e1583c3757b4ba0/src/generic_api.jl#L197">source</a></section></article><h2 id="Derivatives"><a class="docs-heading-anchor" href="#Derivatives">Derivatives</a><a id="Derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#Derivatives" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>API for derivatives is still experimental and subject to change.</p></div></div><p>If derivatives along a coordinate are needed, use <a href="#SpectralKit.derivatives"><code>derivatives</code></a>. For multiple coordinates, the result will be nested in the order of increasing tags. When unspecified, tags are assigned automatically from left to right.</p><article class="docstring"><header><a class="docstring-binding" id="SpectralKit.derivatives" href="#SpectralKit.derivatives"><code>SpectralKit.derivatives</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">derivatives(::Val(I) = Val(0), x, ::Val(N) = Val(1))</code></pre><p>Obtain <code>N</code> derivatives (and the function value) at a scalar <code>x</code>. The <code>i</code>th derivative can be accessed with <code>[i]</code> from results, with <code>[0]</code> for the function value.</p><p><code>I</code> is an integer “tag” for determining the nesting order. Lower <code>I</code> always end up outside when nested. When the defaults are used in multiple coordinates, increasing numbers replace zeros from left to right, starting after the highest explicitly assigned tag.</p><p>Consequently, for most applications, you only need to specify tags if you want a different nesting than left-to-right.</p><p><strong>Important note about transformations</strong></p><p>Always use <code>derivatives</code> <em>before</em> a transformation for correct results. For example, for some transformation <code>I</code> and value <code>x</code> in the transformed domain,</p><pre><code class="language-julia hljs">basis_at(basis2, to_pm1(I, derivatives(x))) # right</code></pre><p>instead of</p><pre><code class="language-julia hljs">basis_at(basis2, derivatives(to_pm1(I, x))) # WRONG</code></pre><p><strong>Univariate example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; basis = Chebyshev(InteriorGrid(), 3)
Chebyshev polynomials (1st kind), InteriorGrid(), dimension: 3

julia&gt; C = collect(basis_at(basis, derivatives(0.1)))
3-element Vector{SpectralKit.Derivatives{0, 2, Float64}}:
 SpectralKit.Derivatives{0, 2, Float64}((1.0, 0.0))
 SpectralKit.Derivatives{0, 2, Float64}((0.1, 1.0))
 SpectralKit.Derivatives{0, 2, Float64}((-0.98, 0.4))

julia&gt; C[1][1]                         # 1st derivative of the linear term is 1
0.0</code></pre><p><strong>Multivariate example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; basis = smolyak_basis(Chebyshev, InteriorGrid(), SmolyakParameters(2), 2)
Sparse multivariate basis on ℝ²
  Smolyak indexing, ∑bᵢ ≤ 2, all bᵢ ≤ 2, dimension 21
  using Chebyshev polynomials (1st kind), InteriorGrid(), dimension: 9

julia&gt; C = collect(basis_at(basis, (derivatives(0.1), derivatives(0.2, Val(2)))));

julia&gt; C[14][1][2]                  # ∂/∂x₁ ∂/∂x₂² of the 14th basis function at x
4.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/SpectralKit.jl/blob/c0d35f7a61f57a7e6885173c7e1583c3757b4ba0/src/derivatives.jl#L73-L127">source</a></section></article><h2 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h2><p>This section of the documentation is probably only relevant to contributors and others who want to understand the internals.</p><h3 id="Simplified-API-for-adding-custom-transformations"><a class="docs-heading-anchor" href="#Simplified-API-for-adding-custom-transformations">Simplified API for adding custom transformations</a><a id="Simplified-API-for-adding-custom-transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Simplified-API-for-adding-custom-transformations" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SpectralKit.UnivariateTransformation" href="#SpectralKit.UnivariateTransformation"><code>SpectralKit.UnivariateTransformation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type UnivariateTransformation</code></pre><p>An abstract type for univariate transformations. Transformations are not required to be subtypes, this just documents the interface they need to support:</p><ul><li><p><a href="#SpectralKit.to_pm1"><code>to_pm1</code></a></p></li><li><p><a href="#SpectralKit.from_pm1"><code>from_pm1</code></a></p></li><li><p><a href="#SpectralKit.domain"><code>domain</code></a></p></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Abstract type used for code organization, not exported.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/SpectralKit.jl/blob/c0d35f7a61f57a7e6885173c7e1583c3757b4ba0/src/transformations.jl#L12">source</a></section></article><h3 id="Grid-internals"><a class="docs-heading-anchor" href="#Grid-internals">Grid internals</a><a id="Grid-internals-1"></a><a class="docs-heading-anchor-permalink" href="#Grid-internals" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SpectralKit.gridpoint" href="#SpectralKit.gridpoint"><code>SpectralKit.gridpoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gridpoint(_, basis, i)
</code></pre><p>Return a gridpoint for collocation, with <code>1 ≤ i ≤ dimension(basis)</code>.</p><p><code>T</code> is used <em>as a hint</em> for the element type of grid coordinates, and defaults to <code>Float64</code>. The actual type can be broadened as required. Methods are type stable.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Not all grids have this method defined, especially if it is impractical. See <a href="#SpectralKit.grid"><code>grid</code></a>, which is part of the API, this function isn&#39;t.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tpapp/SpectralKit.jl/blob/c0d35f7a61f57a7e6885173c7e1583c3757b4ba0/src/chebyshev.jl#L76">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 19 October 2023 07:16">Thursday 19 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
