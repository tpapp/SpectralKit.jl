var documenterSearchIndex = {"docs":
[{"location":"#SpectralKit","page":"SpectralKit","title":"SpectralKit","text":"","category":"section"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"This is a very simple package for building blocks of spectral methods. Its intended audience is users who are familiar with the theory and practice of these methods, and prefer to assemble their code from modular building blocks, potentially reusing calculations. If you need an introduction, a book like Boyd (2001): Chebyshev and Fourier spectral methods is a good place to start.","category":"page"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"This package was designed primarily for solving functional equations, as usually encountered in economics when solving discrete and continuous-time problems. Key features include","category":"page"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"evaluation of univariate and multivatiate basis functions, including Smolyak combinations,\ntransformed to the relevant domains of interest, eg ab  0),\n(partial) derivatives, with correct limits at endpoints,\nallocation-free, thread safe linear combinations for the above with a given set of coefficients,\nusing static arrays extensively to avoid allocation and unroll some loops.","category":"page"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"While there is some functionality in this package to fit approximations to existing functions, it does not use optimized algorithms (DCT) for that, as it was optimized for mapping a set of coefficients to residuals of functional equations at gridpoints.","category":"page"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"Also, while the package should interoperate seamlessly with most AD frameworks, only the derivative API (explained below) is guaranteed to have correct derivatives of limits near infinity.","category":"page"},{"location":"#Concepts","page":"SpectralKit","title":"Concepts","text":"","category":"section"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"In this package,","category":"page"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"A basis is a finite family of functions for approximating other functions. The dimension of a basis tells you how many functions are in there, while domain can be used to query its domain.\nA grid is vector of suggested gridpoints for evaluating the function to be approximated that has useful theoretical properties. You can contruct a collocation_matrix using this grid (or any other set of points). Grids are associated with bases at the time of their construction: a basis with the same set of functions can have different grids.\nbasis_at returns an iterator for evaluating basis functions at an arbitrary point inside their domain. This iterator is meant to be heavily optimized and non-allocating. linear_combination is a convenience wrapper for obtaining a linear combination of basis functions at a given point.","category":"page"},{"location":"#Univariate-basis-example","page":"SpectralKit","title":"Univariate basis example","text":"","category":"section"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"We construct a basis of Chebyshev polynomials on 0 4. This requires a transformation since their canonical domain is -11. Other transformations include SemiInfRational (for A infty intervals)  and InfRational.","category":"page"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"We display the domian and the dimension (number of basis functions).","category":"page"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"using SpectralKit\nbasis = Chebyshev(InteriorGrid(), 5) ‚àò BoundedLinear(0, 4)\ndomain(basis)\ndimension(basis)","category":"page"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"We have chosen an interior grid, shown below. We collect the result for the purpose of this tutorial, since grid returns an iterable to avoid allocations.","category":"page"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"collect(grid(basis))","category":"page"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"We can show evaluate the basis functions at a given point. Again, it is an iterable, so we collect to show it here.","category":"page"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"collect(basis_at(basis, 0.41))","category":"page"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"We can evaluate linear combination as directly, or via partial application.","category":"page"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"Œ∏ = [1, 0.5, 0.2, 0.3, 0.001]               # a vector of coefficients\nx = 0.41\nlinear_combination(basis, Œ∏, x)          # combination at some value\nlinear_combination(basis, Œ∏)(x)          # also as a callable","category":"page"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"We can also evaluate derivatives of either the basis or the linear combination at a given point. Here we want the derivatives up to order 3.","category":"page"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"dx = (ùëë^2)(x)\ncollect(basis_at(basis, dx))\nlinear_combination(basis, Œ∏, x)","category":"page"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"Having an approximation, we can embed it in a larger basis, extending the coefficients accordingly.","category":"page"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"basis2 = Chebyshev(EndpointGrid(), 8) ‚àò transformation(basis)       # 8 Chebyshev polynomials\nis_subset_basis(basis, basis2)              # we could augment Œ∏ ‚Ä¶\naugment_coefficients(basis, basis2, Œ∏)      # ‚Ä¶ so let's do it","category":"page"},{"location":"#Multivariate-(Smolyak)-approximation-example","page":"SpectralKit","title":"Multivariate (Smolyak) approximation example","text":"","category":"section"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"using SpectralKit, StaticArrays\nfunction f2(x)                  # bivariate function we approximate\n    x1, x2 = x                  # takes vectors\n    exp(x1) + exp(-abs2(x2))\nend\nbasis = smolyak_basis(Chebyshev, InteriorGrid2(), SmolyakParameters(3), 2)\nct = coordinate_transformations(BoundedLinear(-1, 2.0), SemiInfRational(-3.0, 3.0))\nbasis_t = basis ‚àò ct\nx = grid(basis_t)\nŒ∏ = collocation_matrix(basis_t) \\ f2.(x)  # find the coefficients\nz = (0.5, 0.7)                            # evaluate at this point\nisapprox(f2(z), linear_combination(basis_t, Œ∏)(z), rtol = 0.005)","category":"page"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"Note how the transformation can be combined with ‚àò to a callable that evaluates a transformed linear combination at z.","category":"page"},{"location":"#Constructing-bases","page":"SpectralKit","title":"Constructing bases","text":"","category":"section"},{"location":"#Grid-specifications","page":"SpectralKit","title":"Grid specifications","text":"","category":"section"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"EndpointGrid\nInteriorGrid\nInteriorGrid2","category":"page"},{"location":"#SpectralKit.EndpointGrid","page":"SpectralKit","title":"SpectralKit.EndpointGrid","text":"struct EndpointGrid <: SpectralKit.AbstractGrid\n\nGrid that includes endpoints (eg Gauss-Lobatto).\n\nnote: Note\nFor small dimensions may fall back to a grid that does not contain endpoints.\n\n\n\n\n\n","category":"type"},{"location":"#SpectralKit.InteriorGrid","page":"SpectralKit","title":"SpectralKit.InteriorGrid","text":"struct InteriorGrid <: SpectralKit.AbstractGrid\n\nGrid with interior points (eg Gauss-Chebyshev).\n\n\n\n\n\n","category":"type"},{"location":"#SpectralKit.InteriorGrid2","page":"SpectralKit","title":"SpectralKit.InteriorGrid2","text":"struct InteriorGrid2 <: SpectralKit.AbstractGrid\n\nGrid with interior points that results in smaller grids than InteriorGrid when nested. Equivalent to an EndpointGrid with endpoints dropped.\n\n\n\n\n\n","category":"type"},{"location":"#Domains-and-transformations","page":"SpectralKit","title":"Domains and transformations","text":"","category":"section"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"A transformation maps values between a domain, usually specified by the basis, and the (co)domain that is specified by a transformation. Transformations are not required to be subtypes of anything, but need to support","category":"page"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"transform_to\ntransform_from\ndomain","category":"page"},{"location":"#SpectralKit.transform_to","page":"SpectralKit","title":"SpectralKit.transform_to","text":"transform_to(domain, transformation, x)\n\nTransform x to domain using transformation.\n\ndomain can be replaced by basis for a shortcut which uses domain(basis).\n\n!!! FIXME     document, especially differentiability requirements at infinite endpoints\n\n\n\n\n\n","category":"function"},{"location":"#SpectralKit.transform_from","page":"SpectralKit","title":"SpectralKit.transform_from","text":"transform_from(domain, transformation, x)\n\nTransform x from domain using transformation.\n\ndomain can be replaced by basis for a shortcut which uses domain(basis).\n\n!!! FIXME     document, especially differentiability requirements at infinite endpoints\n\n\n\n\n\n","category":"function"},{"location":"#SpectralKit.domain","page":"SpectralKit","title":"SpectralKit.domain","text":"domain(basis)\n\nThe domain of a function basis.\n\ndomain(transformation)\n\nThe (co)domain of a transformation. The ‚Äúother‚Äù domain (codomain, depending on the mapping) is provided explicitly for transformations, and should be compatible with thedomain of the basis.\n\nSee domain_kind for the interface supported by domains.\n\n\n\n\n\n","category":"function"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"In most cases you do not need to specify a domain directly: transformations specify their domains (eg from (0 )), and the codomain is determined by a basis. However, the following can be used to construct and query some concrete domains.","category":"page"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"domain_kind\ncoordinate_domains","category":"page"},{"location":"#SpectralKit.domain_kind","page":"SpectralKit","title":"SpectralKit.domain_kind","text":"domain_kind(x)\n\n\nReturn the kind of a domain type (preferred) or value. Errors for objects/types which are not domains. Also works for domains of transformations.\n\nThe following return values are possible:\n\n:univariate, the bounds of which can be accessed using minimum, maximum, and\n\nextrema,\n\n:multivariate, which supports length, getindex ([]), and conversion with Tuple.\n\n\n\n\n\n","category":"function"},{"location":"#SpectralKit.coordinate_domains","page":"SpectralKit","title":"SpectralKit.coordinate_domains","text":"coordinate_domains(domains)\n\n\nCreate domains which are the product of univariate domains. The result support length, indexing with integers, and Tuple for conversion.\n\n\n\n\n\ncoordinate_domains(domains)\n\n\n\n\n\n\ncoordinate_domains(_, domain)\n\n\nCreate a coordinate domain which is the product of domain repeated N times.\n\n\n\n\n\ncoordinate_domains(N, domain)\n\n\n\n\n\n\n","category":"function"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"Bases are defined on a canonical domain, such as -1 1 for Chebyshev polynomials. Transformations map other uni- and multivariate sets into these domains.","category":"page"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"BoundedLinear\nInfRational\nSemiInfRational\ncoordinate_transformations","category":"page"},{"location":"#SpectralKit.BoundedLinear","page":"SpectralKit","title":"SpectralKit.BoundedLinear","text":"struct BoundedLinear{T<:Real} <: SpectralKit.AbstractUnivariateTransformation\n\nTransform the domain to y ‚àà (a, b), using y = x  s + m.\n\nm and s are calculated and checked by the constructor; a < b is enforced.\n\n\n\n\n\n","category":"type"},{"location":"#SpectralKit.InfRational","page":"SpectralKit","title":"SpectralKit.InfRational","text":"InfRational(A, L)\n\n\nThe domain transformed to (-Inf, Inf) using y = A + L  x  (1 - x^2), with L > 0.\n\nExample mappings (for domain (-11))\n\n0  A\n05  A  L  3\n\n\n\n\n\n","category":"type"},{"location":"#SpectralKit.SemiInfRational","page":"SpectralKit","title":"SpectralKit.SemiInfRational","text":"SemiInfRational(A, L)\n\n\nThe domian transformed to  [A, Inf) (when L > 0) or (-Inf,A] (when L < 0) using y = A + L  (1 + x)  (1 - x).\n\nWhen used with Chebyshev polynomials, also known as a ‚Äúrational Chebyshev‚Äù basis.\n\nExample mappings for the domain (-11)\n\n-12  A + L  3\n0  A + L\n12  A + 3  L\n\n\n\n\n\n","category":"type"},{"location":"#SpectralKit.coordinate_transformations","page":"SpectralKit","title":"SpectralKit.coordinate_transformations","text":"coordinate_transformations(transformations)\n\n\nWrapper for coordinate-wise transformations. To extract components, convert to Tuple.\n\njulia> using StaticArrays\n\njulia> ct = coordinate_transformations(BoundedLinear(0, 2), SemiInfRational(2, 3))\ncoordinate transformations\n  (0.0,2.0) ‚Üî domain [linear transformation]\n  (2,‚àû) ‚Üî domain [rational transformation with scale 3]\n\njulia> d1 = domain(Chebyshev(InteriorGrid(), 5))\n[-1,1]\n\njulia> dom = coordinate_domains(d1, d1)\n[-1,1]¬≤\n\njulia> x = transform_from(dom, ct, (0.4, 0.5))\n(1.4, 11.0)\n\njulia> y = transform_to(dom, ct, x)\n(0.3999999999999999, 0.5)\n\n\n\n\n\n","category":"function"},{"location":"#Univariate-bases","page":"SpectralKit","title":"Univariate bases","text":"","category":"section"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"Currently, only Chebyshev polynomials are implemented. Univariate bases operate on real numbers.","category":"page"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"Chebyshev","category":"page"},{"location":"#SpectralKit.Chebyshev","page":"SpectralKit","title":"SpectralKit.Chebyshev","text":"struct Chebyshev{K<:SpectralKit.AbstractGrid} <: SpectralKit.UnivariateBasis\n\nThe first N Chebyhev polynomials of the first kind, defined on [-1,1].\n\n\n\n\n\n","category":"type"},{"location":"#Multivariate-bases","page":"SpectralKit","title":"Multivariate bases","text":"","category":"section"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"Multivariate bases operate on tuples or vectors (StaticArrays.SVector is preferred for performance, but all <:AbstractVector types should work).","category":"page"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"SmolyakParameters\nsmolyak_basis","category":"page"},{"location":"#SpectralKit.SmolyakParameters","page":"SpectralKit","title":"SpectralKit.SmolyakParameters","text":"SmolyakParameters(B)\nSmolyakParameters(B, M)\n\n\nParameters for Smolyak grids that are independent of the dimension of the domain.\n\nPolynomials are organized into blocks (of eg 1, 2, 2, 4, 8, 16, ‚Ä¶) polynomials (and corresponding gridpoints), indexed with a block index b that starts at 0. B ‚â• ‚àë b·µ¢ and 0 ‚â§ b·µ¢ ‚â§ M constrain the number of blocks along each dimension i.\n\nM > B is not an error, but will be normalized to M = B with a warning.\n\n\n\n\n\n","category":"type"},{"location":"#SpectralKit.smolyak_basis","page":"SpectralKit","title":"SpectralKit.smolyak_basis","text":"smolyak_basis(\n    univariate_family,\n    grid_kind,\n    smolyak_parameters,\n    _\n)\n\n\nCreate a sparse Smolyak basis.\n\nArguments\n\nunivariate_family: should be a callable that takes a grid_kind and a dimension parameter, eg Chebyshev.\ngrid_kind: the grid kind, eg InteriorGrid() etc.\nsmolyak_parameters: the Smolyak grid specification parameters, see SmolyakParameters.\nN: the dimension. wrapped in a Val for type stability, a convenience constructor also takes integers.\n\nExample\n\njulia> basis = smolyak_basis(Chebyshev, InteriorGrid(), SmolyakParameters(3), 2)\nSparse multivariate basis on ‚Ñù¬≤\n  Smolyak indexing, ‚àëb·µ¢ ‚â§ 3, all b·µ¢ ‚â§ 3, dimension 81\n  using Chebyshev polynomials (1st kind), InteriorGrid(), dimension: 27\n\njulia> dimension(basis)\n81\n\njulia> domain(basis)\n[-1,1]¬≤\n\nProperties\n\nGrids nest: increasing arguments of SmolyakParameters result in a refined grid that contains points of the cruder grid.\n\n\n\n\n\n","category":"function"},{"location":"#Using-bases","page":"SpectralKit","title":"Using bases","text":"","category":"section"},{"location":"#Introspection","page":"SpectralKit","title":"Introspection","text":"","category":"section"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"is_function_basis\ndimension","category":"page"},{"location":"#SpectralKit.is_function_basis","page":"SpectralKit","title":"SpectralKit.is_function_basis","text":"is_function_basis(::Type{F})\n\nis_function_basis(f::F)\n\nTest if the argument (value or type) is a function basis, supporting the following interface:\n\ndomain for querying the domain,\ndimension for the dimension,\nbasis_at for function evaluation,\ngrid to obtain collocation points.\nlength and getindex for multivariate bases (domain_kind(domain(basis)) == :multivariate), getindex returns a compatible marginal basis\n\nlinear_combination and collocation_matrix are also supported, building on the above.\n\nCan be used on both types (preferred) and values (for convenience).\n\n\n\n\n\n","category":"function"},{"location":"#SpectralKit.dimension","page":"SpectralKit","title":"SpectralKit.dimension","text":"dimension(basis)\n\nReturn the dimension of basis, a positive Int.\n\n\n\n\n\n","category":"function"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"See also domain.","category":"page"},{"location":"#Evaluation","page":"SpectralKit","title":"Evaluation","text":"","category":"section"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"basis_at\nlinear_combination","category":"page"},{"location":"#SpectralKit.basis_at","page":"SpectralKit","title":"SpectralKit.basis_at","text":"basis_at(basis, x)\n\nReturn an iterable with known element type and length (Base.HasEltype(), Base.HasLength()) of basis functions in basis evaluated at x.\n\nUnivariate bases operate on real numbers, while for multivariate bases, Tuples or StaticArrays.SVector are preferred for performance, though all <:AbstractVector types should work.\n\nMethods are type stable.\n\nnote: Note\nConsequences are undefined when evaluating outside the domain.\n\n\n\n\n\n","category":"function"},{"location":"#SpectralKit.linear_combination","page":"SpectralKit","title":"SpectralKit.linear_combination","text":"linear_combination(basis, Œ∏, x)\n\n\nEvaluate the linear combination of  Œ∏‚Çñf‚Çñ(x) of function basis f‚ÇÅ  at x, for the given order.\n\nThe length of Œ∏ should equal dimension(Œ∏).\n\n\n\n\n\nlinear_combination(basis, Œ∏)\n\n\nReturn a callable that calculates linear_combination(basis, Œ∏, x) when called with x.\n\nYou can use linear_combination(basis, Œ∏) ‚àò transformation for domain transformations, though working with basis ‚àò transformation may be preferred.\n\n\n\n\n\n","category":"function"},{"location":"#Grids-and-collocation","page":"SpectralKit","title":"Grids and collocation","text":"","category":"section"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"grid\ncollocation_matrix","category":"page"},{"location":"#SpectralKit.grid","page":"SpectralKit","title":"SpectralKit.grid","text":"grid([T], basis)\n\nReturn an iterator for the grid recommended for collocation, with dimension(basis) elements.\n\nT for the element type of grid coordinates, and defaults to Float64. Methods are type stable.\n\n\n\n\n\n","category":"function"},{"location":"#SpectralKit.collocation_matrix","page":"SpectralKit","title":"SpectralKit.collocation_matrix","text":"collocation_matrix(basis)\ncollocation_matrix(basis, x)\n\n\nConvenience function to obtain a ‚Äúcollocation matrix‚Äù at points x, which is assumed to have a concrete eltype. The default is x = grid(basis), specialized methods may exist for this when it makes sense.\n\nThe collocation matrix may not be an AbstractMatrix, all it needs to support is C \\ y for compatible vectors y = f.(x).\n\nMethods are type stable. The elements of x can be derivatives, see ùëë.\n\n\n\n\n\n","category":"function"},{"location":"#Augment-coordinates-for-a-wider-basis","page":"SpectralKit","title":"Augment coordinates for a wider basis","text":"","category":"section"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"augment_coefficients\nis_subset_basis","category":"page"},{"location":"#SpectralKit.augment_coefficients","page":"SpectralKit","title":"SpectralKit.augment_coefficients","text":"augment_coefficients(basis1, basis2, Œ∏1)\n\nReturn a set of coefficients Œ∏2 for basis2 such that\n\nlinear_combination(basis1, Œ∏1, x) == linear_combination(basis2, Œ∏2, x)\n\nfor any x in the domain. In practice this means padding with zeros.\n\nThrow a ArgumentError if the bases are incompatible with each other or x, or this is not possible. Methods may not be defined for incompatible bases, compatibility between bases can be checked with is_subset_basis.\n\n\n\n\n\n","category":"function"},{"location":"#SpectralKit.is_subset_basis","page":"SpectralKit","title":"SpectralKit.is_subset_basis","text":"is_subset_basis(basis1, basis2)\n\n\nReturn a Bool indicating whether coefficients in basis1 can be augmented to basis2 with augment_coefficients.\n\nnote: Note\ntrue does not mean that coefficients from basis1 can just be padded with zeros, since they may be in different positions. Always use augment_coefficients.\n\n\n\n\n\n","category":"function"},{"location":"#Derivatives","page":"SpectralKit","title":"Derivatives","text":"","category":"section"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"note: Note\nAPI for derivatives is still experimental and subject to change.","category":"page"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"For univariate functions, use ùëë. For multivariate functions, use partial derivatives with ‚àÇ.","category":"page"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"ùëë\n‚àÇ","category":"page"},{"location":"#SpectralKit.ùëë","page":"SpectralKit","title":"SpectralKit.ùëë","text":"A callable that calculates the value and the derivative of the argument. Higher-order derivatives can be obtained by using an exponent, or multiplication.\n\njulia> ùëë(2.0)\n2.0 + 1.0‚ãÖŒî\n\njulia> (ùëë^3)(2.0)\n2.0 + 1.0‚ãÖŒî + 0.0‚ãÖŒî¬≤ + 0.0‚ãÖŒî¬≥\n\nNote that non-literal exponentiation requires ^Val(y), for type stability.\n\nSee linear_combination for examples of evaluating derivatives of basis functions and linear combinations.\n\n\n\n\n\n","category":"constant"},{"location":"#SpectralKit.‚àÇ","page":"SpectralKit","title":"SpectralKit.‚àÇ","text":"‚àÇ(I)\n\n\nPartial derivatives along the given coordinates.\n\n!!! NOTE     Partial derivatives are currently experimental and not heavily tested. API may     change at any point without prior notice or deprecation.\n\nThe following are equivalent, and represent partial_1 partial^2_2, ie the first derivative along the first axis, and the second partial derivative along the second axis.\n\njulia> ‚àÇ(1, 2)\n‚àÇ(1, 2)\n\njulia> ‚àÇ((1, 2))\n‚àÇ(1, 2)\n\nOnly the vararg form allows trailing zeros, which are stripped:\n\njulia> ‚àÇ(1, 0)\n‚àÇ(1)\n\njulia> ‚àÇ((1, 0))\nERROR: ArgumentError: I ‚â° () || last(I) ‚â† 0 must hold.\n\nUse the empty form for no derivatives:\n\njulia> ‚àÇ()\n‚àÇ()\n\nCombine derivatives using union or ‚à™:\n\njulia> ‚àÇ(1, 2) ‚à™ ‚àÇ(2, 1)\nunion(‚àÇ(2, 1), ‚àÇ(1, 2))\n\n\n\n\n\n","category":"function"},{"location":"#Internals","page":"SpectralKit","title":"Internals","text":"","category":"section"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"This section of the documentation is probably only relevant to contributors and others who want to understand the internals.","category":"page"},{"location":"#Type-hierarchies","page":"SpectralKit","title":"Type hierarchies","text":"","category":"section"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"Generally, the abstract types below are not part of the exposed API, and new types don't have to subtype them (unless they want to rely on the existing convenience methods). They are merely for code organization.","category":"page"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"SpectralKit.AbstractUnivariateDomain","category":"page"},{"location":"#SpectralKit.AbstractUnivariateDomain","page":"SpectralKit","title":"SpectralKit.AbstractUnivariateDomain","text":"Univariate domain representation. Supports extrema, minimum, maximum.\n\nnote: Note\nImplementations only need to define extrema.\n\n\n\n\n\n","category":"type"},{"location":"#Grid-internals","page":"SpectralKit","title":"Grid internals","text":"","category":"section"},{"location":"","page":"SpectralKit","title":"SpectralKit","text":"SpectralKit.gridpoint","category":"page"},{"location":"#SpectralKit.gridpoint","page":"SpectralKit","title":"SpectralKit.gridpoint","text":"gridpoint(_, basis, i)\n\n\nReturn a gridpoint for collocation, with 1 ‚â§ i ‚â§ dimension(basis).\n\nT is used as a hint for the element type of grid coordinates. The actual type can be broadened as required. Methods are type stable.\n\nnote: Note\nNot all grids have this method defined, especially if it is impractical. See grid, which is part of the API, this function isn't.\n\n\n\n\n\n","category":"function"}]
}
